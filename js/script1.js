//При помощи цикла for выведите чётные числа от 2 до 10.
/*
for (let i = 2; i <= 10; i++) {
    if (i % 2 == 0) {
        alert(i);
    }
}
*/
//the same result:
/*
for (let i = 2; i <= 10; i++) {
    if (i % 2 !== 0) continue;
    alert(i);
}
*/


//Перепишите код, заменив цикл for на while, без изменения поведения цикла.
/*
for (let i = 0; i < 3; i++) {
    alert(`number ${i}!`);
}
*/
/*
let i = 0;
while (i < 3) {
    alert(`number ${i}!`);
    i++;
}
*/

//цикл, который предлагает prompt ввести число, большее 100.
//Если посетитель ввёл другое число – попросить ввести ещё раз, и так далее.
//Цикл должен спрашивать число пока либо посетитель не введёт число, большее 100,
//либо не нажмёт кнопку Отмена(ESC).
/*
let num;
do {
    num = +prompt('Input a number <100', '');
} while (num <= 100 && num);

Цикл do..while повторяется, пока верны две проверки:

Проверка num <= 100 – то есть, введённое число всё ещё меньше 100.
Проверка && num вычисляется в false, 
когда num имеет значение null или пустая строка ''. 
В этом случае цикл while тоже нужно прекратить.
Кстати, сравнение num <= 100 при вводе null даст true, 
так что вторая проверка необходима.
*/
const n = 10;
nextPrime:
for (let i = 2; i <= n; i++) {
    for (let j = 2; j < i; j++) {
        // if (i % j == 0) {
        //     continue nextPrime;
        // }
    }
    alert(i); // 2, 3, 5, 7
}
/*
let n = 20;
nextPrime:
for (let i = 2; i <= n; i++) {

    for (let j = 2; j < i; j++) {
        if (i % j == 0) continue nextPrime;
    }
    alert(i); // 2, 3, 5, 7

}, где:
for (let i = 2; i <= n; i++) внеш.цикл с внеш.условием
for (let j = 2; j < i; j++) внутр.цикл с внутр.условием
if (i % j == 0) доп.условие во внутр.цикле
continue оператор
nextPrime метка

i = 2 (j = 2)
1) for (let i = 2; 2 <= 10; 
1.1) Вход во внутр.цикл(for (let j = 2; 2 = 2 ) внутр.условие внутр.цикла не выполняется (j < i) (2 = 2). Выход из внутр.цикла. 
1.2) (итерация внутр.цикла j++ не происходит, j остается равным 2)
1.3) Выполнение инструкции alert(i); выводит на экран значение                                    i = 2. 
1.4) Инкрементирование i с помощью i++, теперь i становится равным 3.

i = 3 (j = 2)
2) for (let i = 3; 3 <= 10; 
2.1) Вход во внутр.цикл(for (let j = 2; 2 < 3 ) внутр.условие внутр.цикла выполняется (j < i) (2 < 3). Выход из внутр.цикла. 
2.2) Доп.условие во внутр.цикле if (i % j == 0) не выполняется 3 % 2 без остатка не делится, переходит к следующей итерации внутр.цикла - 
2.3) инкрементирование j с помощью j++, теперь j становится равным 3.                              ???
i = 3; j = 3
2.4) Вход во внутр.цикл(for (let j = 3; 3 = 3 ) внутр.условие внутр.цикла не выполняется (j < i) (3 = 3). Выход из внутр.цикла. 
2.5) (итерация внутр.цикла j++ не происходит, j остается равным 3)
2.6) Выполнение инструкции alert(i); выводит на экран значение                                     i = 3. 
2.7) Инкрементирование i с помощью i++, теперь i становится равным 4.

i = 4 (j = 2)
3) for (let i = 4; 4 <= 10; 
3.1) Вход во внутр.цикл(for (let j = 2; 2 < 4 ) внутр.условие внутр.цикла выполняется (j < i) (2 < 4). Выход из внутр.цикла.
3.2) Доп.условие во внутр.цикле if (i % j == 0) выполняется 4 % 2 без остатка делится, переходит к следующей итерации внутр.цикла - 
3.3) инкрементирование j с помощью j++, теперь j становится равным 3.                              ???
i = 4; j = 3
3.4) контроль передается к метке nextPrime с помощью оператора continue. оператор continue пропускает оставшуюся часть кода внутри внеш.цикла 
3.5) переходит к следующей итерации внеш.цикла - инкрементирование i с помощью i++, теперь i становится равным 5.

i = 5 (j = 2)
4) for (let i = 5; 5 <= 10; 
4.1) Вход во внутр.цикл(for (let j = 2; 2 < 5 ) внутр.условие внутр.цикла выполняется (j < i) (2 < 5). Выход из внутр.цикла. 
4.2) Доп.условие во внутр.цикле if (i % j == 0) не выполняется 5 % 2 без остатка не делится, переходит к следующей итерации внутр.цикла - 
4.3) инкрементирование j с помощью j++, теперь j становится равным 3.
i = 5 (j = 3)
4.4) Вход во внутр.цикл(for (let j = 3; 3 < 5 ) внутр.условие внутр.цикла выполняется (j < i) (3 < 5). Выход из внутр.цикла. 
4.5) Доп.условие во внутр.цикле if (i % j == 0) не выполняется 5 % 2 без остатка не делится, переходит к следующей итерации внутр.цикла - 
4.6) инкрементирование j с помощью j++, теперь j становится равным 4.
i = 5; j = 4
4.7) Вход во внутр.цикл(for (let j = 4; 4 < 5 ) внутр.условие внутр.цикла не выполняется (j < i) (4 < 5). Выход из внутр.цикла. 
4.8) Доп.условие во внутр.цикле if (i % j == 0) не выполняется 5 % 4 без остатка не делится, переходит к следующей итерации внутр.цикла - 
4.9) инкрементирование j с помощью j++, теперь j становится равным 5.
i = 5; j = 5
4.10) Вход во внутр.цикл(for (let j = 5; 5 = 5 ) внутр.условие внутр.цикла не выполняется (j < i) (5 = 5). Выход из внутр.цикла. 
4.11) (итерация внутр.цикла j++ не происходит, j остается равным 5)
4.12) Выполнение инструкции alert(i); выводит на экран значение                    i = 5. 
4.13) инкрементирование i с помощью i++, теперь i становится равным 6.

i = 6 (j = 2)
5) for (let i = 6; 6 <= 10; 
5.1) Вход во внутр.цикл(for (let j = 2; 2 < 6 ) внутр.условие выполняется (j < i) (2 < 6). Выход из внутр.цикла.
5.2) доп.условие во внутр.цикле if (i % j == 0) выполняется 6 % 3 без остатка делится, переходит к следующей итерации внутр.цикла - 
5.3) инкрементирование j с помощью j++, теперь j становится равным 3.
i = 6; j = 3
5.4) контроль передается к метке nextPrime с помощью оператора continue. оператор continue пропускает оставшуюся часть кода внутри внеш.цикла 
5.5) переходит к следующей итерации внеш.цикла - инкрементирование i с помощью i++, теперь i становится равным 7.

i = 7 (j = 2)
6) for (let i = 7; 7 <= 10; 
6.1) Вход во внутренний цикл(for (let j = 2; 2 < 7 ) внутр.условие выполняется (j < i) (2 < 7). Выход из внутр.цикла. 
6.2) доп.условие во внутр.цикле if (i % j == 0) не выполняется 7 % 2 без остатка не делится, переходит к следующей итерации внутр.цикла - 
6.3) инкрементирование j с помощью j++, теперь j становится равным 3.
i = 7 (j = 3)
6.4) Вход во внутр.цикл(for (let j = 3; 3 < 7 ) внутр.условие внутр.цикла выполняется (j < i) (3 < 7). Выход из внутр.цикла. 
6.5) Доп.условие во внутр.цикле if (i % j == 0) не выполняется 7 % 3 без остатка не делится, переходит к следующей итерации внутр.цикла - 
6.6) инкрементирование j с помощью j++, теперь j становится равным 4.
i = 7; j = 4
6.7) Вход во внутр.цикл(for (let j = 4; 4 < 7 ) внутр.условие внутр.цикла выполняется (j < i) (4 < 7). Выход из внутр.цикла.
6.8) Доп.условие во внутр.цикле if (i % j == 0) не выполняется 7 % 4 без остатка не делится, переходит к следующей итерации внутр.цикла -  
6.9) инкрементирование j с помощью j++, теперь j становится равным 5.
i = 7; j = 5
6.7) Вход во внутр.цикл(for (let j = 5; 5 < 7 ) внутр.условие внутр.цикла выполняется (j < i) (5 < 7). Выход из внутр.цикла. 
6.8) Доп.условие во внутр.цикле if (i % j == 0) не выполняется 7 % 5 без остатка не делится, переходит к следующей итерации внутр.цикла -  
6.9) инкрементирование j с помощью j++, теперь j становится равным 6.
i = 7; j = 6
6.10) Вход во внутр.цикл(for (let j = 6; 6 < 7 ) внутр.условие внутр.цикла выполняется (j < i) (6 < 7). Выход из внутр.цикла. 
6.11) Доп.условие во внутр.цикле if (i % j == 0) не выполняется 7 % 6 без остатка не делится, переходит к следующей итерации внутр.цикла - 
6.12) инкрементирование j с помощью j++, теперь j становится равным 7.
i = 7; j = 7
6.13) Вход во внутр.цикл(for (let j = 7; 7 = 7 ) внутр.условие внутр.цикла не выполняется (j < i) (7 = 7). Выход из внутр.цикла. 
6.14) (итерация внутр.цикла j++ не происходит, j остается равным 7)
6.15) Выполнение инструкции alert(i); выводит на экран значение                     i = 7. 
6.16) инкрементирование i с помощью i++, теперь i становится равным 8.

i = 8 (j = 2)
7) for (let i = 8; 8 <= 10; 
7.1) Вход во внутр.цикл(for (let j = 2; 2 < 8 ) внутр.условие внутр.цикла выполняется (j < i) (4 < 8). Выход из внутр.цикла.
7.2) Доп.условие во внутр.цикле if (i % j == 0) выполняется 8 % 2 без остатка делится, переходит к следующей итерации внутр.цикла - 
7.3) инкрементирование j с помощью j++, теперь j становится равным 3.                              ???
i = 8; j = 3
7.4) контроль передается к метке nextPrime с помощью оператора continue. оператор continue пропускает оставшуюся часть кода внутри внеш.цикла 
7.5) переходит к следующей итерации внеш.цикла - инкрементирование i с помощью i++, теперь i становится равным 9.

i = 9 (j = 2)
8) for (let i = 9; 9 <= 10; 
8.1) Вход во внутр.цикл(for (let j = 2; 2 < 9 ) внутр.условие внутр.цикла выполняется (j < i) (2 < 9). Выход из внутр.цикла....
8.2) доп.условие во внутр.цикле if (i % j == 0) не выполняется 9 % 2 без остатка не делится, переходит к следующей итерации внутр.цикла - 
8.3) инкрементирование j с помощью j++, теперь j становится равным 3.
i = 9 (j = 3)
8.4) Вход во внутр.цикл(for (let j = 3; 3 < 9 ) внутр.условие внутр.цикла выполняется (j < i) (3 < 8). Выход из внутр.цикла.
8.5) Доп.условие во внутр.цикле if (i % j == 0) выполняется 9 % 3 без остатка делится, переходит к следующей итерации внутр.цикла - 
8.6) инкрементирование j с помощью j++, теперь j становится равным 4.                              ???
i = 9; j = 3
8.7) контроль передается к метке nextPrime с помощью оператора continue. оператор continue пропускает оставшуюся часть кода внутри внеш.цикла 
8.8) переходит к следующей итерации внеш.цикла - инкрементирование i с помощью i++, теперь i становится равным 10.

i = 10 (j = 2)
9) for (let i = 10; 10 <= 10; внутр.условие внеш.цикла не выполняется. цикл останавливается


*/